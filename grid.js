require('dotenv').config();
const { Hyperliquid } = require('hyperliquid');
const readline = require('readline');

// Param√®tres de la grille
const GRID_LEVELS = 3;
const GRID_SPREAD = 0.01; // 1% au-dessus et en dessous du prix spot

// Mapping pour les tokens connus
const COIN_MAP = {
    "BTC": "UBTC",
    "BTC-USDC": "UBTC-USDC",
    // Ajoute d'autres mappings si besoin
};

function getCoinFromSymbol(symbol) {
    const base = symbol.split('-')[0].toUpperCase();
    return COIN_MAP[base] || base;
}

function roundTo8(x) {
    // Arrondit √† 8 d√©cimales, supprime les z√©ros inutiles
    return Number.parseFloat(x).toFixed(8).replace(/\.?0+$/, '');
}

const sdk = new Hyperliquid({
    privateKey: process.env.HL_PRIVATE_KEY,
    walletAddress: process.env.HL_WALLET_ADDRESS
});

function ask(question) {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });
    return new Promise(resolve => rl.question(question, ans => {
        rl.close();
        resolve(ans);
    }));
}

async function getSpotPrice(symbol) {
    const coin = getCoinFromSymbol(symbol);
    const allMids = await sdk.info.getAllMids();
    const keys = Object.keys(allMids);

    // Affiche tous les march√©s disponibles pour debug
    console.log("March√©s disponibles :", keys.join(', '));

    // Recherche d'une cl√© qui commence par le coin et contient 'SPOT'
    const spotKey = keys.find(
        k => k.toUpperCase().startsWith(coin) && k.toUpperCase().includes('SPOT')
    );
    if (!spotKey) {
        throw new Error("March√© spot non trouv√© pour " + coin + ". Cl√©s disponibles : " + keys.join(', '));
    }
    return parseFloat(allMids[spotKey]);
}

function buildGrid(centerPrice, levels, spread) {
    const prices = [];
    for (let i = 0; i < levels; i++) {
        const offset = (i - Math.floor(levels / 2)) * spread;
        const gridPrice = centerPrice * (1 + offset);
        prices.push(Number(gridPrice.toFixed(2)));
    }
    return prices;
}

function distributeCapital(capital, levels) {
    const amountPerLevel = capital / levels;
    return Array(levels).fill(Number(amountPerLevel.toFixed(6)));
}

async function placeOrder(symbol, side, price, quantity) {
    const coin = getCoinFromSymbol(symbol);
    const allMids = await sdk.info.getAllMids();
    const keys = Object.keys(allMids);
    const spotKey = keys.find(
        k => k.toUpperCase().startsWith(coin) && k.toUpperCase().includes('SPOT')
    );
    if (!spotKey) {
        throw new Error("Impossible de trouver la cl√© spot pour la paire " + symbol);
    }
    const order = {
        coin: spotKey,
        is_buy: side === "buy",
        sz: quantity,
        limit_px: price,
        reduce_only: false,
        order_type: { limit: { tif: 'Gtc' } }
    };
    console.log(`üöÄ Envoi de l'ordre LIVE:`, order);
    const res = await sdk.exchange.placeOrder(order);
    if (res.status === "ok") {
        console.log("‚úÖ Ordre envoy√© avec succ√®s:", res);
    } else {
        console.log("‚ùå Erreur lors de l'envoi de l'ordre:", res);
    }
    return res;
}

async function main() {
    console.log("üîÅ Lancement du Grid Trading Bot (Hyperliquid SDK Node.js)...");

    const symbol = (await ask("ü™ô Quelle paire veux-tu trader ? (ex: BTC-USDC) : ")).toUpperCase();
    const totalCapital = parseFloat(await ask("üí∞ Capital √† allouer (en USDC) : "));

    let spotPrice;
    try {
        spotPrice = await getSpotPrice(symbol);
    } catch (e) {
        console.error("‚ùå Impossible de r√©cup√©rer le prix spot :", e.message);
        process.exit(1);
    }
    console.log(`üìà Prix spot actuel pour ${symbol} : ${spotPrice} USDC`);

    const grid = buildGrid(spotPrice, GRID_LEVELS, GRID_SPREAD);
    const allocations = distributeCapital(totalCapital, GRID_LEVELS);

    console.log("\nüìã Strat√©gie Grid Trading :");
    for (let i = 0; i < GRID_LEVELS; i++) {
        console.log(`Grille ${i+1}: Prix ${grid[i]} USDC ‚Üí Allocation ${allocations[i]} USDC`);
    }

    const confirmation = (await ask("\n‚úÖ Confirmer le placement des ordres (LIVE) ? (o/n) : ")).toLowerCase();
    if (confirmation !== "o") {
        console.log("‚ùå Annul√© par l'utilisateur.");
        process.exit(0);
    }

    for (let i = 0; i < GRID_LEVELS; i++) {
        const price = grid[i];
        let quantity = allocations[i] / price;
        quantity = roundTo8(quantity);
        await placeOrder(symbol, "buy", price, quantity);
        await new Promise(r => setTimeout(r, 1000));
    }
}

main();
